// Define the main rule to capture the entire program
program = _{ SOI ~ program_declaration* ~ EOI }

WHITESPACE = _{ " " | "\t" | "\u{000C}" | NEWLINE }
// Comments
COMMENT       = _{ LINE_COMMENT | BLOCK_COMMENT }
LINE_COMMENT  = _{ "//" ~ (!NEWLINE ~ ANY)* }
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Operators
ARITHMETIC_OPERATOR          = @{ "+" | "-" | "*" | "/" | "%" }
ARITHMETIC_DOUBLED_OPERATOR  = @{ "++" | "--" | "**" | "//" }
RELATIONAL_OPERATOR          =  { "==" | "!=" | ">" | "<" | ">=" | "<=" }
LOGICAL_OPERATOR             =  { "&&" | "||" | "!" }
BITWISE_OPERATOR             =  { "&" | "|" | "^" | "~" | "<<" | ">>" }
VARIABLE_ASSIGNMENT_OPERATOR =  { "=" }
ASSIGNMENT_OPERATOR          =  { "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" }
OPERATOR                     = _{
    ARITHMETIC_OPERATOR
  | ARITHMETIC_DOUBLED_OPERATOR
  | RELATIONAL_OPERATOR
  | LOGICAL_OPERATOR
  | BITWISE_OPERATOR
  | ASSIGNMENT_OPERATOR
  | VARIABLE_ASSIGNMENT_OPERATOR
}

/// values / type
VALUE               = _{ INTEGER | FLOAT | CHARACTER | STRING | NULLPTR | NULL | ARRAY | BOOLEAN }
INTEGER             = @{ "-"? ~ (DECIMAL_INTEGER | HEXADECIMAL_INTEGER) }
DECIMAL_INTEGER     = _{ INTEGER_PART ~ EXPONENT_PART? }
HEXADECIMAL_INTEGER = _{ "0x" ~ ASCII_HEX_DIGIT+ }

FLOAT         = @{ "-"? ~ DECIMAL_FLOAT | EXPONENT_FLOAT | HEXADECIMAL_FLOAT }
DECIMAL_FLOAT = _{
    ((INTEGER_PART ~ FRACTION_PART) | (FRACTION_PART) | (INTEGER_PART ~ ".")) ~ "f"?
}
INTEGER_PART  = _{ ASCII_DIGIT+ }
FRACTION_PART = _{ "." ~ ASCII_DIGIT+ }
EXPONENT_PART = _{ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

EXPONENT_FLOAT = { (INTEGER_PART | FRACTION_PART | INTEGER_PART ~ FRACTION_PART) ~ EXPONENT_PART }

HEXADECIMAL_FLOAT = { HEXADECIMAL_INTEGER ~ "." ~ ASCII_HEX_DIGIT+ ~ ("p" | "P") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

CHARACTER = { "'" ~ (!"'" ~ ANY) ~ "'" }
STRING    = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
NULL      = { "NULL" | "Null" | "null" | "NIL" | "Nil" | "nil" | "NONE" | "None" | "none" | "Nu" | "nu" | "Mu" | "mu" }
NULLPTR   = { "nullptr" | "Nullptr" | "NullPtr" | "NULLPTR" }
ARRAY     = { "[" ~ (VALUE ~ ("," ~ VALUE)*)? ~ "]" }
BOOLEAN   = { "true" | "false" | "True" | "False" | "TRUE" | "FALSE" }

STRUCT_DECLARATION         =  { "struct" ~ "{" ~ (VARIABLE_DECLARATION)* ~ "}" ~ VARIABLE_IDENTIFIER }
STRUCT_VARIABLE_IDENTIFIER =  { VARIABLE_IDENTIFIER ~ ("." ~ VARIABLE_IDENTIFIER)+ }
CLASS_DECLARATION          =  { "class" ~ VARIABLE_IDENTIFIER ~ "{" ~ ((PREFIX_ACCESS_MODIFIER ~ ":") ~ (VARIABLE_DECLARATION | FUNCTION_DECLARATION)*)+ ~ "};" }
CLASS_VARIABLE_IDENTIFIER  = _{ STRUCT_VARIABLE_IDENTIFIER | VARIABLE_IDENTIFIER }

/// end of values
PRESERVED_KEYWORD = _{ CONDITION_STATEMENT_KEYWORD | LOOP_STATEMENT_KEYWORD | FUNCTION_RETURN_STATEMENT_KEYWORD | VOID_DATA_TYPE | BASIC_DATA_TYPE | EXTEND_BASIC_DATA_TYPE | PREFIX_ACCESS_MODIFIER | PREFIX_STORAGE_MODIFIER | PREFIX_TYPE_MODIFIER | PREFIX_DATA_SIZE | VALUE }

// Variable Declaration Terms
VARIABLE_IDENTIFIER        = @{ (ASCII_ALPHA | "_") ~ ("_" | ASCII_ALPHANUMERIC)* }
OUTTER_VARIABLE_IDENTIFIER = @{ "$" ~ VARIABLE_IDENTIFIER }

DATA_TYPE               = _{ BASIC_DATA_TYPE | EXTEND_BASIC_DATA_TYPE | SELF_DEFINED_DATA_TYPE }
VOID_DATA_TYPE          =  { "void" | "VOID" }
BASIC_DATA_TYPE         = _{ "int" | "INT" | "float" | "FLOAT" | "double" | "DOUBLE" | "char" | "CHAR" | "bool" | "BOOL" }
EXTEND_BASIC_DATA_TYPE  = _{ "string" | "STRING" | "tensor" | "TENSOR" | "vector" | "VECTOR" | "object" | "OBJECT" }
SELF_DEFINED_DATA_TYPE  = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC)* }
PUBLIC_ACCESS_MOD       = @{ "public" | "pub" | "PUBLIC" | "PUB" }
PRIVATE_ACCESS_MOD      = @{ "private" | "priv" | "PRIVATE" | "PRIV" }
PROTECTED_ACCESS_MOD    = @{ "protected" | "prot" | "PROTECTED" | "PROT" }
PREFIX_ACCESS_MODIFIER  = _{ PUBLIC_ACCESS_MOD | PRIVATE_ACCESS_MOD | PROTECTED_ACCESS_MOD }
PREFIX_STORAGE_MODIFIER =  { "static" | "extern" | "register" | "auto" | "typedef" | "STATIC" | "EXTERN" | "REGISTER" | "AUTO" | "TYPEDEF" }
PREFIX_TYPE_MODIFIER    =  { "const" | "volatile" | "restrict" | "CONST" | "VOLATILE" | "RESTRICT" }
PREFIX_DATA_SIZE        =  { "short" | "long" | "SHORT" | "LONG" }

REFERENCE_ADDRESS_MOD = @{ "&" }
REFERENCE_POINTER_MOD = @{ "*" }
// PREFIX_REFERENCE_MONDIFIER = _{ (REFERENCE_ADDRESS_MOD+ | REFERENCE_POINTER_MOD+) }
// REFERENCE_DATA_TYPE        =  { DATA_TYPE ~ PREFIX_REFERENCE_MONDIFIER }
REFERENCE_ADDRESS_IDENTIFIER = @{ REFERENCE_ADDRESS_MOD ~ VARIABLE_IDENTIFIER }
// REFERENCE_POINTER_TYPE       =  { DATA_TYPE ~ REFERENCE_POINTER_MOD }

POSTFIX_ARRAY_DECL = @{ "[" ~ (INTEGER | "_" | VARIABLE_IDENTIFIER | OUTTER_VARIABLE_IDENTIFIER) ~ "]" }

VARIABLE_DECLARATION_PREFIX                 = _{ PREFIX_ACCESS_MODIFIER? ~ PREFIX_STORAGE_MODIFIER? ~ PREFIX_TYPE_MODIFIER? ~ PREFIX_DATA_SIZE? }
variable_type_declaration                   = _{ variable_type_declaration_simple | variable_type_declaration_reference_address | variable_type_declaration_pointer | variable_type_declaration_outter_reference }
variable_type_declaration_outter_reference  = @{ DATA_TYPE ~ WHITE_SPACE ~ OUTTER_VARIABLE_IDENTIFIER ~ POSTFIX_ARRAY_DECL? }
variable_type_declaration_simple            = @{ DATA_TYPE ~ WHITE_SPACE ~ VARIABLE_IDENTIFIER ~ POSTFIX_ARRAY_DECL? }
variable_type_declaration_reference_address = @{ DATA_TYPE ~ WHITE_SPACE ~ REFERENCE_ADDRESS_MOD ~ VARIABLE_IDENTIFIER ~ POSTFIX_ARRAY_DECL? }
variable_type_declaration_pointer           = @{ DATA_TYPE ~ WHITE_SPACE? ~ REFERENCE_POINTER_MOD ~ WHITE_SPACE? ~ VARIABLE_IDENTIFIER ~ POSTFIX_ARRAY_DECL? }

// Variable Declaration Patterns
VARIABLE_DECLARATION                 = { VARIABLE_DECLARATION_PREFIX ~ variable_type_declaration ~ ("," ~ VARIABLE_IDENTIFIER ~ POSTFIX_ARRAY_DECL?)* ~ ";" }
VARIABLE_DECLARATION_WITH_ASSIGNMENT = { VARIABLE_DECLARATION_PREFIX ~ variable_type_declaration ~ VALUE_DIRECT_EXPRESSION ~ ";" }

// expression
VALUEABLE_EXPRESSION = { accessable_valueable ~ (BITWISE_OPERATOR ~ accessable_valueable)* }
accessable_valueable = {
    VALUE
  | FUNCTION_IDENTIFIER
  | FUNCTION_CALL_EXPRESSION
  | VARIABLE_IDENTIFIER
  | OUTTER_VARIABLE_IDENTIFIER
  | REFERENCE_ADDRESS_IDENTIFIER
}
// RIGHT_HAND_EXPRESSION    = _{ VALUE_DIRECT_EXPRESSION }
VALUE_DIRECT_EXPRESSION  = { VARIABLE_ASSIGNMENT_OPERATOR ~ (VALUEABLE_EXPRESSION) }
FUNCTION_CALL_EXPRESSION = { (FUNCTION_IDENTIFIER | VARIABLE_IDENTIFIER) ~ ("<" ~ DATA_TYPE ~ ">")? ~ "(" ~ (VALUEABLE_EXPRESSION ~ ","?)* ~ ")" }

// function
FUNCTION_DECLARATION_PREFIX       =  { PREFIX_ACCESS_MODIFIER? ~ PREFIX_DATA_SIZE? }
FUNCTION_DECLARATION_NAME         = @{ function_declaration ~ ("::" ~ VARIABLE_IDENTIFIER)* }
function_declaration              = _{ variable_type_declaration_simple | variable_type_declaration_reference_address | variable_type_declaration_pointer | variable_type_declaration_outter_reference | function_declaration_void }
function_declaration_void         =  { VOID_DATA_TYPE ~ WHITE_SPACE ~ VARIABLE_IDENTIFIER }
FUNCTION_IDENTIFIER               = @{ ("&"? ~ "*"?) ~ VARIABLE_IDENTIFIER ~ ("::" ~ VARIABLE_IDENTIFIER)+ }
FUNCTION_DECLARATION_ARGS         =  { (variable_type_declaration) ~ ("," ~ variable_type_declaration)* }
FUNCTION_DECLARATION              =  {
    FUNCTION_DECLARATION_PREFIX? ~ FUNCTION_DECLARATION_NAME ~ "(" ~ FUNCTION_DECLARATION_ARGS? ~ ")" ~ "{" ~ (STATEMENT | FUNCTION_RETURN_STATEMENT)* ~ "}"
}
FUNCTION_CALL_STATEMENT           = _{ FUNCTION_CALL_EXPRESSION ~ ";" }
FUNCTION_RETURN_STATEMENT         =  { "return" ~ (VALUEABLE_EXPRESSION ~ (ARITHMETIC_OPERATOR ~ VALUEABLE_EXPRESSION)*)? ~ ";" }
FUNCTION_RETURN_STATEMENT_KEYWORD = _{ "return" | "RETURN" }

STATEMENT         = _{ VARIABLE_DECLARATION | VARIABLE_DECLARATION_WITH_ASSIGNMENT | (VALUE_OPERATION_STATMENT ~ ";") | COMPOUND_STATEMENT | LOOP_STATEMENT | FUNCTION_CALL_STATEMENT | FUNCTION_RETURN_STATEMENT | CONDITION_STATEMENT | COMMENT | UNSUPPORTED_STATEMENT | LOOP_BREAK_STATEMENT | LOOP_CONTINUE_STATEMENT }
COMPARE_STATEMENT =  { (VARIABLE_IDENTIFIER | OUTTER_VARIABLE_IDENTIFIER) ~ (RELATIONAL_OPERATOR ~ VALUEABLE_EXPRESSION)? }

/// operation
VALUE_OPERATION_STATMENT         =  { (VARIABLE_IDENTIFIER | OUTTER_VARIABLE_IDENTIFIER) ~ (rh_direct_operation | rh_shorthand_operation | rh_shorthand_self_operation) }
rh_direct_operation_pattern_head =  { (VARIABLE_ASSIGNMENT_OPERATOR | ASSIGNMENT_OPERATOR) ~ VALUEABLE_EXPRESSION }
rh_direct_operation_pattern_tail =  { (ARITHMETIC_OPERATOR ~ VALUEABLE_EXPRESSION | ARITHMETIC_DOUBLED_OPERATOR ~ VALUEABLE_EXPRESSION?) }
rh_direct_operation              = _{ rh_direct_operation_pattern_head ~ rh_direct_operation_pattern_tail* }
rh_shorthand_operation           = _{ ASSIGNMENT_OPERATOR ~ VALUEABLE_EXPRESSION }
rh_shorthand_self_operation      = _{ ARITHMETIC_DOUBLED_OPERATOR }
// rh_bitwise_operation             = _{ VARIABLE_ASSIGNMENT_OPERATOR ~ VALUEABLE_EXPRESSION ~ BITWISE_OPERATOR ~ VALUEABLE_EXPRESSION }
COMPOUND_STATEMENT = { "{" ~ (!COMPOUND_STATEMENT ~ STATEMENT)* ~ "}" }

/// loop related
for_loop_initial_state  =  { "int" ~ VARIABLE_IDENTIFIER ~ "=" ~ VALUEABLE_EXPRESSION }
FOR_LOOP_CONDITION      =  { for_loop_initial_state ~ ";" ~ COMPARE_STATEMENT ~ ";" ~ VALUE_OPERATION_STATMENT }
FOR_LOOP_RANGE          =  { VARIABLE_IDENTIFIER ~ ("in" | "of") ~ (VALUEABLE_EXPRESSION | (INTEGER ~ ".." ~ INTEGER) | (VALUEABLE_EXPRESSION ~ "[" ~ INTEGER ~ ":" ~ INTEGER ~ "]")) }
FOR_LOOP_STATEMENT      =  { "for" ~ "(" ~ (FOR_LOOP_CONDITION | FOR_LOOP_RANGE) ~ ")" ~ LOOP_COMPOUND_STATEMENT }
WHILE_LOOP_STATEMENT    =  { "while" ~ "(" ~ COMPARE_STATEMENT ~ ")" ~ LOOP_COMPOUND_STATEMENT }
DO_WHILE_LOOP_STATEMENT =  { "do" ~ LOOP_COMPOUND_STATEMENT ~ "while" ~ "(" ~ COMPARE_STATEMENT ~ ")" ~ ";" }
LOOP_COMPOUND_STATEMENT =  { "{" ~ (STATEMENT)* ~ "}" }
LOOP_BREAK_STATEMENT    = @{ "break" ~ ";" }
LOOP_CONTINUE_STATEMENT = @{ "continue" ~ ";" }
LOOP_STATEMENT          = _{ FOR_LOOP_STATEMENT | WHILE_LOOP_STATEMENT | DO_WHILE_LOOP_STATEMENT }
LOOP_STATEMENT_KEYWORD  = _{ "for" | "in" | "of" | "while" | "do" | "break" | "continue" | "FOR" | "IN" | "OF" | "WHILE" | "DO" | "BREAK" | "CONTINUE" }

/// condition related
IF_CONDITION_STATEMENT      =  { "if" ~ "(" ~ COMPARE_STATEMENT ~ ")" ~ COMPOUND_STATEMENT ~ ("else" ~ "if" ~ "(" ~ COMPARE_STATEMENT ~ ")" ~ COMPOUND_STATEMENT)* ~ ("else" ~ COMPOUND_STATEMENT)? }
SWITCH_CONDITION_STATEMENT  =  { "switch" ~ "(" ~ (VALUEABLE_EXPRESSION | COMPARE_STATEMENT) ~ ")" ~ "{" ~ SWITCH_CASE_STATEMENT* ~ "}" }
SWITCH_CASE_STATEMENT       =  { ("case" ~ VALUEABLE_EXPRESSION | "case" ~ "_" | "default") ~ ":" ~ STATEMENT* ~ LOOP_BREAK_STATEMENT }
CONDITION_STATEMENT         = _{ IF_CONDITION_STATEMENT | SWITCH_CONDITION_STATEMENT }
CONDITION_STATEMENT_KEYWORD = _{ "if" | "else" | "switch" | "case" | "default" | "IF" | "ELSE" | "SWITCH" | "CASE" | "DEFAULT" }

UNSUPPORTED_STATEMENT = @{ "#" ~ ASCII_ALPHA+ ~ (!NEWLINE ~ ANY)* }

program_declaration = _{ STATEMENT | FUNCTION_DECLARATION | WHITESPACE }
